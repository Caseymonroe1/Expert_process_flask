{% extends "layout.html" %} {% block problem %}
<div class="text-block-content-1">
  <pre><code>import matplotlib.pyplot as plt 
    # Linear Regression 
    class LinearRegression() : 
        def __init__( self, learning_rate, iterations ) : 
            self.learning_rate = learning_rate 
            self.iterations = iterations 
            
        # Function for model training         
        def fit( self, X, Y ) : 
            # no_of_training_examples, no_of_features 
            self.m, self.n = X.shape 
            # weight initialization 
            self.W = np.zeros( self.n ) 
            self.b = 0
            self.X = X 
            self.Y = Y 
            # gradient descent learning 
            for i in range( self.iterations ) : 
                self.update_weights() 
            return self
        
        # Helper function to update weights in gradient descent 
        def update_weights( self ) : 
            Y_pred = self.predict( self.X ) 
            # calculate gradients 
            dW = - ( 2 * ( self.X.T ).dot( self.Y - Y_pred ) ) / self.m 
            db = - 2 * np.sum( self.Y - Y_pred ) / self.m 
            # update weights 
            self.W = self.W - self.learning_rate * dW 
            self.b = self.b - self.learning_rate * db 
            return self
        
        # Hypothetical function h( x ) 
        def predict( self, X ) : 
            return X.dot( self.W ) + self.b 

    # driver code 
    def main() : 
        # Importing dataset 
        df = pd.read_csv( "salary_data.csv" ) 
        X = df.iloc[:,:-1].values 
        Y = df.iloc[:,1].values 
        
        # Splitting dataset into train and test set 
        X_train, X_test, Y_train, Y_test = train_test_split( 
        X, Y, test_size = 1/3, random_state = 0 ) 
        
        # Model training 
        model = LinearRegression( iterations = 1000, learning_rate = 0.01 ) 
        model.fit( X_train, Y_train ) 
        # Prediction on test set 
        Y_pred = model.predict( X_test ) 
        print( "Predicted values ", np.round( Y_pred[:3], 2 ) ) 
        print( "Real values     ", Y_test[:3] ) 
        print( "Trained W     ", round( model.W[0], 2 ) ) 
        print( "Trained b     ", round( model.b, 2 ) ) 
  </code></pre>
</div>
{% endblock %} {% block explanation %}
<div class="text-block-content-2">
  In Python, a function is a block of organized, reusable code designed to
  perform a single, related action, enhancing modularity and code reusability in
  applications. A function is created with the **`def`** keyword, followed by
  the function name and parentheses, which may include parameters or arguments.
  The code block within a function starts with a colon and is indented, and the
  first statement can be an optional documentation string (docstring) to
  describe the function's purpose. Functions can be of different types:
  **built-in functions**, which are pre-defined in Python like `print()`,
  `len()`, and `type()`, **user-defined functions**, which are created by users
  to perform specific tasks, and **anonymous functions**, or **lambda
  functions**, defined using the **`lambda`** keyword without a name. To execute
  a function, it must be called by its name followed by parentheses, optionally
  including arguments if needed. Functions can take parameters, acting as
  placeholders for the values it needs to operate on, with the actual values
  passed to the function being referred to as arguments. One of the powerful
  features of Python functions is their ability to return values using the
  **`return`** statement. The scope of variables within functions is also an
  important concept; variables declared inside a function are local to that
  function, while variables declared outside are in the global scope. Python
  supports several types of arguments: **positional arguments**, which are
  passed in order from left to right, **keyword arguments**, which are passed by
  explicitly naming each parameter, **default arguments**, which are given
  default values if no argument value is passed during the function call, and
  **variable-length arguments**, which allow passing a variable number of
  arguments to a function, distinguished as *args for non-keyword arguments and
  **kwargs for keyword arguments. Understanding and utilizing these concepts and
  types of functions and arguments are essential for effective Python
  programming. Delving into each of these areas, especially the creation and use
  of **user-defined functions**, **lambda functions**, the concept of **scope**,
  **return values**, and the different **argument types**, can significantly
  enhance one's programming skills and problem-solving capabilities in Python.
</div>
{% endblock %} {% block graph %}
<div class="text-block-content-3">
  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
  incididunt ut labore et dolore magna aliqua. Neque aliquam vestibulum morbi
  blandit cursus.
</div>
{% endblock %}
