{% extends "layout.html" %} {% block problem %}
<div class="text-block-content-1">
  <pre><code>import matplotlib.pyplot as plt 
    # Linear Regression 
    class LinearRegression() : 
        def __init__( self, learning_rate, iterations ) : 
            self.learning_rate = learning_rate 
            self.iterations = iterations 
            
        # Function for model training         
        def fit( self, X, Y ) : 
            # no_of_training_examples, no_of_features 
            self.m, self.n = X.shape 
            # weight initialization 
            self.W = np.zeros( self.n ) 
            self.b = 0
            self.X = X 
            self.Y = Y 
            # gradient descent learning 
            for i in range( self.iterations ) : 
                self.update_weights() 
            return self
        
        # Helper function to update weights in gradient descent 
        def update_weights( self ) : 
            Y_pred = self.predict( self.X ) 
            # calculate gradients 
            dW = - ( 2 * ( self.X.T ).dot( self.Y - Y_pred ) ) / self.m 
            db = - 2 * np.sum( self.Y - Y_pred ) / self.m 
            # update weights 
            self.W = self.W - self.learning_rate * dW 
            self.b = self.b - self.learning_rate * db 
            return self
        
        # Hypothetical function h( x ) 
        def predict( self, X ) : 
            return X.dot( self.W ) + self.b 

    # driver code 
    def main() : 
        # Importing dataset 
        df = pd.read_csv( "salary_data.csv" ) 
        X = df.iloc[:,:-1].values 
        Y = df.iloc[:,1].values 
        
        # Splitting dataset into train and test set 
        X_train, X_test, Y_train, Y_test = train_test_split( 
        X, Y, test_size = 1/3, random_state = 0 ) 
        
        # Model training 
        model = LinearRegression( iterations = 1000, learning_rate = 0.01 ) 
        model.fit( X_train, Y_train ) 
        # Prediction on test set 
        Y_pred = model.predict( X_test ) 
        print( "Predicted values ", np.round( Y_pred[:3], 2 ) ) 
        print( "Real values     ", Y_test[:3] ) 
        print( "Trained W     ", round( model.W[0], 2 ) ) 
        print( "Trained b     ", round( model.b, 2 ) ) 
  </code></pre>
</div>
{% endblock %} {% block explanation %}
<div class="text-block-content-2">
  <h2>Understanding Python Functions</h2>
  <p>
    In Python, a <strong>function</strong> is a block of organized, reusable
    code designed to perform a single, related action. This enhances modularity
    and code reusability in applications. A function is created with the
    <code>def</code> keyword, followed by the function name and parentheses.
    These parentheses may include parameters or arguments. The code block within
    a function starts with a colon and is indented. The first statement can be
    an optional documentation string (docstring) to describe the function's
    purpose.
  </p>

  <h3>Types of Functions</h3>
  <ul>
    <li>
      <strong>Built-in functions</strong>, which are pre-defined in Python like
      <code>print()</code>, <code>len()</code>, and <code>type()</code>.
    </li>
    <li>
      <strong>User-defined functions</strong>, which are created by users to
      perform specific tasks.
    </li>
    <li>
      <strong>Anonymous functions</strong>, or
      <strong>lambda functions</strong>, defined using the
      <code>lambda</code> keyword without a name.
    </li>
  </ul>

  <h3>Executing Functions</h3>
  <p>
    To execute a function, it must be called by its name followed by
    parentheses, optionally including arguments if needed. Functions can take
    parameters, acting as placeholders for the values it needs to operate on.
    The actual values passed to the function are referred to as arguments.
  </p>

  <h3>Features of Python Functions</h3>
  <p>
    One of the powerful features of Python functions is their ability to return
    values using the <code>return</code> statement. The scope of variables
    within functions is also an important concept; variables declared inside a
    function are local to that function, while variables declared outside are in
    the global scope.
  </p>

  <h3>Types of Arguments</h3>
  <p>Python supports several types of arguments:</p>
  <ul>
    <li>
      <strong>Positional arguments</strong>, which are passed in order from left
      to right.
    </li>
    <li>
      <strong>Keyword arguments</strong>, which are passed by explicitly naming
      each parameter.
    </li>
    <li>
      <strong>Default arguments</strong>, which are given default values if no
      argument value is passed during the function call.
    </li>
    <li>
      <strong>Variable-length arguments</strong>, which allow passing a variable
      number of arguments to a function. These are distinguished as
      <em>args</em> for non-keyword arguments and <em>**kwargs</em> for keyword
      arguments.
    </li>
  </ul>

  <p>
    Understanding and utilizing these concepts and types of functions and
    arguments are essential for effective Python programming. Delving into each
    of these areas, especially the creation and use of user-defined functions,
    lambda functions, the concept of scope, return values, and the different
    argument types, can significantly enhance one's programming skills and
    problem-solving capabilities in Python.
  </p>
</div>
{% endblock %} {% block graph %}
<div class="text-block-content-3">
  <iframe
    src="{{ url_for('my_flowchart') }}"
    style="width: 100%; height: 100%; border: none"
  ></iframe>
</div>
{% endblock %}
